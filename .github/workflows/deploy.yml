name: Deploy to Environment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - qa
          - prod

env:
  AWS_REGION: ${{ secrets.AWS_REGION || 'eu-south-2' }}

jobs:
  build-and-push:
    name: Build and Push to ECR (${{ github.event.inputs.environment }})
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set image tag
        id: set-tag
        run: |
          echo "image_tag=${{ github.event.inputs.environment }}-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push API image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: milky-way-api
          IMAGE_TAG: ${{ steps.set-tag.outputs.image_tag }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
                       -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
                       --target production \
                       -f apps/api/Dockerfile \
                       .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Set API URL for environment
        id: set-api-url
        run: |
          if [[ "${{ github.event.inputs.environment }}" == "prod" ]]; then
            echo "api_url=${{ secrets.PROD_API_URL }}" >> $GITHUB_OUTPUT
          else
            echo "api_url=${{ secrets.QA_API_URL }}" >> $GITHUB_OUTPUT
          fi

      - name: Build and push Web Admin image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: milky-way-web-admin
          IMAGE_TAG: ${{ steps.set-tag.outputs.image_tag }}
          NEXT_PUBLIC_API_URL: ${{ steps.set-api-url.outputs.api_url }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
                       -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
                       --build-arg NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL \
                       --target production \
                       -f apps/web-admin/Dockerfile \
                       .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Image build summary
        run: |
          echo "### Docker Images Built :whale:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **API:** ${{ steps.login-ecr.outputs.registry }}/milky-way-api:${{ steps.set-tag.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Web Admin:** ${{ steps.login-ecr.outputs.registry }}/milky-way-web-admin:${{ steps.set-tag.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy to ${{ github.event.inputs.environment }}
    runs-on: ubuntu-latest
    needs: build-and-push

    environment:
      name: ${{ github.event.inputs.environment }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set EC2 host
        id: set-host
        run: |
          if [[ "${{ github.event.inputs.environment }}" == "prod" ]]; then
            echo "ec2_host=${{ secrets.PROD_EC2_HOST }}" >> $GITHUB_OUTPUT
          else
            echo "ec2_host=${{ secrets.QA_EC2_HOST }}" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ steps.set-host.outputs.ec2_host }} >> ~/.ssh/known_hosts

      - name: Create fetch-secrets script
        run: |
          cat > /tmp/fetch-secrets.sh << 'EOF'
          #!/bin/bash
          set -e

          SECRET_NAME="${ENVIRONMENT}/app-secrets"
          REGION="${AWS_REGION}"

          echo "Fetching secrets from AWS Secrets Manager..."

          # Fetch secrets
          SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id $SECRET_NAME --region $REGION --query SecretString --output text 2>/dev/null || echo "{}")

          # Parse and create .env file
          if [ "$SECRET_JSON" != "{}" ]; then
              echo "$SECRET_JSON" | jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' > /opt/app/.env
              echo "Secrets fetched successfully"
          else
              echo "Warning: No secrets found in Secrets Manager. Creating placeholder .env"
              touch /opt/app/.env
          fi

          chmod 600 /opt/app/.env
          EOF

      - name: Deploy to EC2
        env:
          EC2_HOST: ${{ steps.set-host.outputs.ec2_host }}
          ENVIRONMENT: ${{ github.event.inputs.environment }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          # Copy deployment files to EC2
          scp -i ~/.ssh/deploy_key docker-compose.prod.yml ec2-user@$EC2_HOST:/tmp/
          scp -i ~/.ssh/deploy_key /tmp/fetch-secrets.sh ec2-user@$EC2_HOST:/tmp/

          ssh -i ~/.ssh/deploy_key ec2-user@$EC2_HOST bash -s << ENDSSH
            set -e

            # Create app directory if it doesn't exist
            sudo mkdir -p /opt/app
            sudo chown -R ec2-user:ec2-user /opt/app

            # Navigate to app directory
            cd /opt/app

            # Move docker-compose file
            mv /tmp/docker-compose.prod.yml /opt/app/docker-compose.prod.yml

            # Move fetch-secrets script if it doesn't exist
            if [ ! -f "/opt/app/fetch-secrets.sh" ]; then
              mv /tmp/fetch-secrets.sh /opt/app/fetch-secrets.sh
              chmod +x /opt/app/fetch-secrets.sh
            fi

            # Authenticate with ECR
            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY

            # Set environment variables for fetch-secrets
            export ENVIRONMENT=$ENVIRONMENT
            export AWS_REGION=$AWS_REGION

            # Fetch latest secrets
            ./fetch-secrets.sh

            # Pull latest images
            export ECR_REGISTRY=$ECR_REGISTRY
            export IMAGE_TAG=latest
            export ENVIRONMENT=$ENVIRONMENT
            export AWS_REGION=$AWS_REGION

            docker-compose -f docker-compose.prod.yml pull

            # Run database migrations
            docker-compose -f docker-compose.prod.yml run --rm api npx prisma migrate deploy

            # Restart services with zero-downtime (force recreate to use new images)
            docker-compose -f docker-compose.prod.yml up -d --force-recreate --no-deps web
            docker-compose -f docker-compose.prod.yml up -d --force-recreate --no-deps api

            # Wait for health checks
            echo "Waiting for services to be healthy..."
            sleep 30

            # Verify API health
            if curl -f http://localhost:4000/api/health; then
              echo "API is healthy"
            else
              echo "API health check failed"
              docker-compose -f docker-compose.prod.yml logs api
              exit 1
            fi

            # Verify Web health
            if curl -f http://localhost:3000; then
              echo "Web is healthy"
            else
              echo "Web health check failed"
              docker-compose -f docker-compose.prod.yml logs web
              exit 1
            fi

            # Clean up old images
            docker image prune -f

            echo "Deployment completed successfully!"
          ENDSSH

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/deploy_key

      - name: Deployment summary
        run: |
          echo "### Deployment Summary :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Host:** ${{ steps.set-host.outputs.ec2_host }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
